### 学习笔记

#### 结题思路着重强调

1. 审题（边界）
2. 可能的解决方案 -> 最优解
3. 编码
4. 测试用例

#### Java HashMap总结

JDK源码版本：MASTER分支，JDK-15

**HashMap结构**
1. Node节点构成的数组
2. Node节点内next属性构成的单链表

**`get`方法核心流程**  
1. 值hash后根据hash值取模
2. 判断取模后的索引处是否存在Node的头结点
3. 存在且key值equals相等返回节点本身否则判断链表下一个节点是否为空
4. 下一节点链表不为空则判断节点类型
    a. 树节点：红黑树遍历
    b. 其他：链表循环知道key相等后返回

**值hash后根据hash值取模**

主要思想： 除留余数法
公式：`(h = key.hashCode()) ^ (h >>> 16) & (n - 1)` => `(h = key.hashCode()) ^ (h >>> 16) % n`  
成立前提：n必须为2的指数次方  

`(h = key.hashCode()) ^ (h >>> 16)`原因：  
1. 长度为2的指数次方，对其`& (n - 1)`则相当于低位掩码，即：相当于用低16位来做数组下表访问
2. 为解决低位与碰撞的，将高16位与低16位异或加大随机性以减少碰撞hash值的碰撞几率

留下个疑问？  
为啥需要判断 `first.hash == hash`，根据注释，官方的说明 always check first node

**`put`方法核心流程**  

1. 值hash
2. 判断是否需要扩容（数组为空）
3. 创建节点  
    a. 取模后索引位置无数据，创建头结点  
    b. 查找到需要插入的位置，节点存在则根据`onlyIfAbsent`为false或者新建的节点则赋值，返回旧值  
4. 增加修改标记（用于并发控制）
5. 哈希表大于阈值，扩容处理
6. 返回null

扩容流程：  
1. 旧的容量 > 0  
    a. 达到`MAXIMUM_CAPACITY`（2^30），则标记阈值为`Integer.MAX_VALUE`(2^31- 1)  
    b. 对老容量`<< 1`后小于`MAXIMUM_CAPACITY`且老容量大于默认容量大小`DEFAULT_INITIAL_CAPACITY`，则标记阈值为`<< 1`（两倍）  
2. 旧阈值 > 0
    新容量 = 旧阈值
3. 新容量 = 默认初始化容量（16）；新阈值 = 默认负载因子（0.75） * 默认初始化容量（16）  
4. 新的阈值为0

1. 第一次初始化扩容  
    a. 初始化容量与阈值  
2. 第二次扩容  
    a. 限制容量大小并设置扩容阈值为2倍  
    b. 循环原数组，并对不为null的节点做处理   
        i. 无next，即单头结点，则重新按照新的容量大小rehash  
        ii. 树节点类型的节点重排  
        iii. 单链表  
            * 哈希表按照2次幂重新扩容后，原节点的hash值要不为原值要不为原位置移动2次幂的位置  
            * 拆分两个子链表，原位置链表与新位置链表。并倒序构建
 

#### 